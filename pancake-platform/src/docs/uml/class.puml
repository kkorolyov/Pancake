@startuml

package platform {
	class GameLoop {
		handle(long)
	}

	class GameEngine {
		update(long)
	}

	abstract class GameSystem {
		update(Entity, long)
	}

	class Limiter {
		boolean isReady(long)
	}

	class PerformanceCounter {
		start()
		end(GameSystem)
	}

	class Config

	abstract class Launcher {
		start(Stage)
	}

	package event {
  	class EventBroadcaster {
  		register(String, Consumer<?>)
  		enqueue(String, Object)
  		int broadcast()
  	}
  }

  package entity {
  	class Entity
  	class EntityPool

  	class Signature {
  		boolean masks(Signature)
  	}

  	class Component

  	Entity o-- "1" Signature
  	Entity *-- "*" Component

  	EntityPool *-- "*" Entity

  	Signature --> Signature: masks
  }

  package media {
  	class Camera {
  		Vector getAbsolutePosition(Vector)
			Vector getRelativePosition(Vector)
  	}

  	class CompositeImage

  	class ImagePool {
  		put(Properties)
		}

		class SoundPool {
			put(Properties)
		}

  	ImagePool o-- "*" CompositeImage
  }

  package input {
		class Action {
			Consumer<Entity> signal(boolean, float)
		}

		class KeyAction {
			Consumer<Entity> signal(Set<Enum<?>>, float)
		}

		class ActionPool {
			put(Properties)
			Iterable<KeyAction> parseConfig(Properties)
		}

		KeyAction o-- "1" Action

		ActionPool o-- "*" Action
		ActionPool --> KeyAction: creates
  }

  package math {
	  class Vector

	  class WeightedDistribution

	  class Collider {
	  	{static} Vector intersection(Vector, Vector, Vector, Vector)
			{static} Vector intersection(Vector, float, Vector, float)
			{static} Vector intersection(Vector, Vector, Vector, float)
			{static} void elasticCollide(Vector, Vector, float, Vector, Vector, float)
	  }
  }

  package storage {
  	abstract class Storable<T extends Storable> {
  		~ int changed(StorableChangeEvent)
			T register(StorableListener)
			T copy()
  	}
  	interface StorableListener

		class storage.Entity
		class storage.Component
		class storage.Attribute

		package serialization {
			interface Serializer<T> {
				T read(String)
				String write(T)
			}
			class EntitySerializer
			class ComponentSerializer
			class AttributeSerializer

			interface ValueParser {
				Object parse(String)
				boolean accepts(String)
			}
			package strategy {
				ValueParser <|-- MapParser
				ValueParser <|-- NumberParser
				ValueParser <|-- StringParser
				ValueParser <|-- URIParser
			}

			Serializer <|-- EntitySerializer
			Serializer <|-- ComponentSerializer
			Serializer <|-- AttributeSerializer

			EntitySerializer --> storage.Entity: serializes
			ComponentSerializer --> storage.Component: serializes
			AttributeSerializer --> storage.Attribute: serializes
		}

		Storable ..|> Serializable
		Storable o-- "*" StorableListener
		Storable <|-- storage.Entity
		Storable <|-- storage.Component
		Storable <|-- storage.Attribute

		storage.Entity o-- "*" storage.Component
		storage.Component o-- "*" storage.Attribute
  }

  GameLoop *-- "1" GameEngine

  GameEngine *-- "1" EventBroadcaster
  GameEngine *-- "1" EntityPool
	GameEngine *-- "*" GameSystem

	GameEngine --> GameSystem: updates
	GameEngine --> PerformanceCounter: queries

	GameSystem --> Signature: filters by
	GameSystem --> Entity: updates

	Limiter --> GameSystem: limits

	PerformanceCounter --> GameSystem: times

	Launcher --> GameLoop: initializes
}

@enduml
