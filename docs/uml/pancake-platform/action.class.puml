@startuml

abstract class Action {
	-signature: Signature
	__
	#Action([Class<? extends Component>])
	--
	{abstract} #apply(id: int, entities: EntityPool)
	+accept(id: int, entities: EntityPool)
}
Action -> dev.kkorolyov.pancake.platform.entity.Entity

class CollectiveAction {
	-delegates: {Action}
}
Action <|-- CollectiveAction

class FreeFormAction {
	-consumer: BiConsumer<Integer, EntityPool>
}
Action <|-- FreeFormAction

class KeyAction {
	-delegate: MultiStageAction
	-inputs: {Enum}
	__
	+arm(inputs: {Enum}, dt: float)
}
Action <|-- KeyAction
KeyAction -> MultiStageAction

class MultiStageAction {
	-start: Action
	-hold: Action
	-end: Action
	..
	-holdTime: float
	..
	-ArmingOption
	-State
	__
	+arm(ArmingOption, dt: float)
}
Action <|-- MultiStageAction
MultiStageAction +-- ArmingOption
MultiStageAction +-- State
enum ArmingOption {
	+ACTIVATE
	+DEACTIVATE
}
abstract class State {
	{static} -INACTIVE: State
	{static} -ACTIVE: State
	{static} -DECAYED: State

	{abstract} ~apply(id: int, entities: EntityPool, client: MultiStageAction)
	~accept(id: int, entities: EntityPool, Action)
}

class ActionRegistry {
	-actions: {String, Action}
	..
	-ActionContainerSerializer
	-KeyActionSerializer
	__
	+get(name: String): Action
	+getName(Action): String
	+put(name: String, Action): ActionRegistry
	..
	+put(path: String): ActionRegistry
	+readKeys(path: String): Iterable<KeyAction>
}
ActionRegistry o- Action

@enduml
